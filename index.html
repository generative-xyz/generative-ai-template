<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>A simple template for drawing art with perceptron model on Bitcoin</title>

    <!--
    Generative supports the most popular creative coding libraries. Simply uncomment the library you want to use below.
    Are we missing an important library? Let us know @generative_xyz.
    -->

    <!-- p5js@1.5.0
    <script sandbox="allow-scripts" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js"></script>
    -->

    <!-- c2.min.js@1.0.0
    <script sandbox="allow-scripts" type="text/javascript" src="https://cdn.generative.xyz/ajax/libs/c2/1.0.0/c2.min.js"></script>
    -->

    <!-- chromajs@2.4.2
    <script sandbox="allow-scripts" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"></script>
    -->

    <!-- p5.grain.js@0.6.1
    <script sandbox="allow-scripts" type="text/javascript" src="https://cdn.generative.xyz/ajax/libs/p5.grain/0.6.1/p5.grain.min.js"></script>
    -->

    <!-- threejs@r124
    <script sandbox="allow-scripts" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r124/three.min.js"></script>
    -->

    <!-- tonejs@14.8.49
    <script sandbox="allow-scripts" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    -->

    <!-- svgjs@3.1.2
    <script sandbox="allow-scripts" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.2/svg.min.js"></script>
    -->

    <!-- aframejs@1.2.0
    <script sandbox="allow-scripts" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.2.0/aframe.min.js"></script>
    -->

    <!-- babylonjs@5.47.0
    <script sandbox="allow-scripts" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/5.47.0/babylon.js"></script>
    -->

    <!-- paperjs@0.12.17
    <script sandbox="allow-scripts" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.17/paper-full.min.js"></script>
    -->

    <!-- regljs@2.1.0
    <script sandbox="allow-scripts" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/regl/2.1.0/regl.min.js"></script>
    -->

    <script type="text/javascript">
    // --------------- UTILS LIB ---------------
    function zip(rows) {
        return rows[0].map((_, i) => rows.map(row => row[i]));
    }

    function clone(items) {
        return items.map(item => Array.isArray(item) ? clone(item) : item);
    }

    function isNullOrEmpty(str) {
        return str == null || str === '';
    }

    function base64_to_hex(str) {
        const raw = atob(str);
        let result = '';
        for (let i = 0; i < raw.length; i++) {
            const hex = raw.charCodeAt(i).toString(16);
            result += (hex.length === 2 ? hex : '0' + hex);
        }
        return result.toLowerCase();        
    }

    // --------------- TENSORFAKE LIB ---------------

    class Tensor {
        constructor(data, n, m) {
            this.n = n;
            this.m = m;
            this.mat = [];
            
            let p = 0;
            for(let i = 0; i < this.n; ++i) {
                this.mat.push([]);
                for(let j = 0; j < this.m; ++j) {
                    this.mat[i].push(p < data.length ? data[p] : 0.0);
                    p += 1;
                }
            }
            return this;
        }

        copy() {
            return new Tensor(this.mat.flat(), this.n, this.m);
        }
    }

    class tfake {
        static __linear = (x) => x;
        static __relu = (x) => Math.max(x, 0);
        static __leaky_relu = (x) => x > 0 ? x : x * 0.2;
        static __sigmoid = (x) => 1 / (1 + Math.exp(-x));
        static __tanh = (x) => Math.tanh(x);

        static __apply_unary_op(a, op) {
            const res = a.copy();
            for(let i = 0; i < res.n; ++i) {
                for(let j = 0; j < res.m; ++j) {
                    res.mat[i][j] = op(res.mat[i][j]);
                }
            }
            return res;
        }

        static linear = (a) => tfake.__apply_unary_op(a, tfake.__linear);
        static relu = (a) => tfake.__apply_unary_op(a, tfake.__relu);
        static leaky_relu = (a) => tfake.__apply_unary_op(a, tfake.__leaky_relu);
        static sigmoid = (a) => tfake.__apply_unary_op(a, tfake.__sigmoid);
        static tanh = (a) => tfake.__apply_unary_op(a, tfake.__tanh);
        
        static __add = (a, b) => a + b;
        static __mul = (a, b) => a * b;

        static __apply_binary_op = (a, b, op) => {
            if (typeof b !== 'object') {
                b = new Tensor([b], 1, 1);
            }

            const res = a.copy();
            for(let i = 0; i < res.n; ++i) {
                for(let j = 0; j < res.m; ++j) {
                    res.mat[i][j] = op(res.mat[i][j], b.mat[i%b.n][j%b.m]);
                }
            }
            return res;
        }

        static mul = (a, b) => tfake.__apply_binary_op(a, b, tfake.__mul);
        static add = (a, b) => tfake.__apply_binary_op(a, b, tfake.__add);

        static matMul(a, b) {
            const res = new Tensor([], a.n, b.m);
            for(let i = 0; i < res.n; ++i) {
                for(let j = 0; j < res.m; ++j) {
                    for(let k = 0; k < a.m; ++k) {
                        res.mat[i][j] += a.mat[i][k] * b.mat[k][j];
                    }
                }
            }
            return res;
        }

        static softmax(a) {
            const res = tfake.__apply_unary_op(a, x => Math.exp(x));
            const sum_e = res.mat.flat().reduce((a, b) => a + b);
            for(let i = 0; i < a.n; ++i) {
                for(let j = 0; j < a.m; ++j) {
                    res.mat[i][j] /= sum_e;
                }
            }
            return res;
        }
    }

    // --------------- PERCEPTRON LIB ---------------

    class RescaleLayer {
        constructor(scale, offset) {
            this.scale = scale;
            this.offset = offset;
        }

        forward(x) {
            return tfake.add(tfake.mul(x, this.scale), this.offset);
        }
    }

    class FlattenLayer {
        constructor() {}

        forward(x) {
            return x.map(e => e.flat());
        }
    }

    class DenseLayer {
        constructor(out_dim, activation, w, b) {
            this.out_dim = out_dim;
            this.activation = activation;
            this.w = w;
            this.b = b;
        }

        forward(x) {
            const y = tfake.add(tfake.matMul(x, this.w), this.b);
            const z = (this.activation == null) ? y : this.activation(y);
            return z;
        }
    }

    class MultilayerPerceptron {
        constructor(preprocessLayers, hiddenLayers, outputLayer) {
            this.preprocessLayers = preprocessLayers;
            this.hiddenLayers = hiddenLayers;
            this.outputLayer = outputLayer;
        }

        getInfo() {
            return {
                hiddenNeurons: this.hiddenLayers.map(e => e.out_dim),
                activationFunc: getNameFromActivation(this.hiddenLayers[0].activation),
                parameters: this.hiddenLayers.map(e => ({
                    w: e.w, 
                    b: e.b,
                })),
            };
        }

        forward(x) {
            for (const layer of this.preprocessLayers) {
                x = layer.forward(x);
            }
            for (const layer of this.hiddenLayers) {
                x = layer.forward(x);
            }
            x = this.outputLayer.forward(x);
            return tfake.softmax(x);
        }
    }

    // --------------- MODEL LIB ---------------

    class Model {
        constructor(inscription) {
            const { model_name, layers_config, weight_b64, classes_name } = inscription;
            const { perceptron, inputDim } = loadPerceptron(layers_config, weight_b64);
            this.perceptron = perceptron;
            this.inputDim = inputDim;
            this.modelName = model_name;
            this.classesName = classes_name;
        }

        getInfo() {
            const { hiddenNeurons, activationFunc, parameters } = this.perceptron.getInfo();
            return {
                inputDim: this.inputDim,
                parameters,
                hiddenNeurons,
                activationFunc,
                modelName: this.modelName,
                classesName: this.classesName,
            };
        }

        classifyImage(pixels) {
            const img_tensor = new Tensor(pixels, 1, pixels.length);
        
            const result_tensor = this.perceptron.forward(img_tensor);
            const result = result_tensor.mat[0];
        
            return result;
        }        
    };

    function loadPerceptron(layersConfig, weights_b64) {
        const preprocessLayers = [];
        const hiddenLayers = [];

        const weights = base64ToFloatArray(weights_b64);

        let dim = null;
        let p = 0;
        let inputDim = [];
        for(const info of layersConfig.config.layers) {
            if (info.class_name == "InputLayer") {
                dim = info.config.batch_input_shape.slice(1);
                inputDim = dim;
            } else if (info.class_name == "Rescaling") {
                preprocessLayers.push(new RescaleLayer(info.config.scale, info.config.offset))
            } else if (info.class_name == "Flatten") {
                dim = [dim.reduce((a, b) => a * b)]
            } else if (info.class_name == "Dense") {
                const nxt_dim = [info.config.units];
                const w_size = dim[0] * nxt_dim[0];
                const b_size = nxt_dim[0];

                const w_array = weights.subarray(p, p + w_size);
                p += w_size;
                const b_array = weights.subarray(p, p + b_size);
                p += b_size;

                const w_tensor = new Tensor(w_array, dim[0], nxt_dim[0]);
                const b_tensor = new Tensor(b_array, 1, nxt_dim[0]);
                const activation = getActivationFromName(info.config.activation);

                hiddenLayers.push(new DenseLayer(nxt_dim[0], activation, w_tensor, b_tensor));

                dim = nxt_dim;
            }
        }

        const outputLayer = hiddenLayers.pop();

        const perceptron = new MultilayerPerceptron(preprocessLayers, hiddenLayers, outputLayer);
        return { perceptron, inputDim };
    }

    // Modified from https://gist.github.com/sketchpunk/f5fa58a56dcfe6168a9328e7c32a4fd4
    function base64ToFloatArray(base64) {
        // Base64 string converted to a char array
        const blob	= window.atob(base64);
        // How many floats can be made, but be even
        const fLen = blob.length / Float32Array.BYTES_PER_ELEMENT;
        // ArrayBuffer/DataView to convert 4 bytes into 1 float.          
        const dView = new DataView( new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT) );
        // Final Output at the correct size
        const fAry = new Float32Array(fLen);
        // Position
        let p = 0; 

        for(let j=0; j < fLen; j++){
            p = j * 4;
            for(let b = 0; b < 4; ++b) {
                dView.setUint8(b,blob.charCodeAt(p+b));
            }
            fAry[j] = dView.getFloat32(0,true);
        }
        return fAry;
    }

    function getActivationFromName(name) {
        switch (name) {
            case "relu": 
                return tfake.relu;
            case "sigmoid": 
                return tfake.sigmoid;
            case "tanh": 
                return tfake.tanh;
            case "leaky_relu": 
                return tfake.leaky_relu;
            case "linear":
            default:
                return tfake.linear;
        }
    }

    function getNameFromActivation(func) {
        switch (func) {
            case tfake.relu: 
                return "ReLU";
            case tfake.sigmoid: 
                return "Sigmoid";
            case tfake.tanh: 
                return "Tanh";
            case tfake.leaky_relu: 
                return "LeakyReLU";
            case tfake.linear:
                return "Linear";
            default:
                return "Unknown";
        }
    }

    // --------------- API LIB ---------------

    // TODO: Storing inscription_ids_base64 in an inscription after all of the Perceptron collection are minted
    const inscription_ids_base64 = `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`;
    const inscription_ids = base64_to_hex(inscription_ids_base64);

    async function fetchData(endpoint, options) {
        try {
            const response = await fetch(endpoint, options);
            const data = await response.text();
            return data;
        } catch (err) {
            console.log(err);
            return null;
        }
    }

    async function getModelInscription(endpoint) {
        return await getValidModelInscription(endpoint);
    }
    
    async function isValidModelInscriptionEndpoint(endpoint) {  
        return await getValidModelInscription(endpoint) != null;
    }

    function getModelInscriptionFromPerceptronHTML(rawHTML) {
        const start = rawHTML.indexOf(`const p={"`) + 8;
        const end = rawHTML.indexOf(`"]},`) + 3;
        const rawJSON = rawHTML.substring(start, end);
        try {
            const inscription = JSON.parse(rawJSON);
            return inscription;            
        } catch (err) {
            console.log(`Invalid JSON: ${rawJSON}`);
            return null;
        }
    }

    async function getValidModelInscription(endpoint) {
        if (isNullOrEmpty(endpoint)) return null;
        
        let inscription = null;
        // Check if endpoint is a number from 1 to 580 file
        if (Number.isInteger(endpoint) && endpoint >= 1 && endpoint <= 580) {
            const index = endpoint - 1;
            const id = inscription_ids.substring(64 * index, 64 * (index + 1));
            if (id === "0000000000000000000000000000000000000000000000000000000000000000") {
                console.log(`Perceptron #${endpoint} is not minted`);
            } else {
                const uri = `https://ordinals.com/content/${id}i0`;
                const rawData = await fetchData(uri, {});
                inscription = getModelInscriptionFromPerceptronHTML(rawData);                
            }
        } else {
            const rawData = await fetchData(endpoint, {});
            try {
                // Check if endpoint is a JSON file
                inscription = JSON.parse(rawData);
            } catch (err) {
                // If not, endpoint is assumed to be a HTML from Perceptron collection
                inscription = getModelInscriptionFromPerceptronHTML(rawData);
            }
        }

        if (verifyModelInscription(inscription)) return inscription;
        return null;
    }

    function verifyModelInscription(inscription) {
        if (inscription == null) return false;

        const { classes_name, training_traits, layers_config, weight_b64 } = inscription;

        if (!Array.isArray(classes_name)) return false;
        if (training_traits == null) return false;
        try {
            loadPerceptron(layers_config, weight_b64);
        } catch (err) {
            return false;
        }

        return true;
    }

    </script>

    <script id="snippet-random-code" type="text/javascript">

        // DO NOT EDIT THIS SECTION

        let seed = window.location.href.split('/').find(t => t.includes('i0'));

        if (seed == null) {
            const alphabet = "0123456789abcdefghijklmnopqrstuvwsyz";
            seed = new URLSearchParams(window.location.search).get("seed") || Array(64).fill(0).map(_ => alphabet[(Math.random() * alphabet.length) | 0]).join('') + "i0";
        } else {
            let pattern = "seed=";
            for (let i = 0; i < seed.length - pattern.length; ++i) {
                if (seed.substring(i, i + pattern.length) == pattern) {
                    seed = seed.substring(i + pattern.length);
                    break;
                }
            }
        }

        function cyrb128($) {
            let _ = 1779033703, u = 3144134277, i = 1013904242, l = 2773480762;
            for (let n = 0, r; n < $.length; n++) _ = u ^ Math.imul(_ ^ (r = $.charCodeAt(n)), 597399067), u = i ^ Math.imul(u ^ r, 2869860233), i = l ^ Math.imul(i ^ r, 951274213), l = _ ^ Math.imul(l ^ r, 2716044179);
            return _ = Math.imul(i ^ _ >>> 18, 597399067), u = Math.imul(l ^ u >>> 22, 2869860233), i = Math.imul(_ ^ i >>> 17, 951274213), l = Math.imul(u ^ l >>> 19, 2716044179), [(_ ^ u ^ i ^ l) >>> 0, (u ^ _) >>> 0, (i ^ _) >>> 0, (l ^ _) >>> 0]
        }

        function sfc32($, _, u, i) {
            return function () {
                u >>>= 0, i >>>= 0;
                var l = ($ >>>= 0) + (_ >>>= 0) | 0;
                return $ = _ ^ _ >>> 9, _ = u + (u << 3) | 0, u = (u = u << 21 | u >>> 11) + (l = l + (i = i + 1 | 0) | 0) | 0, (l >>> 0) / 4294967296
            }
        }


        // IMPORTANT: Instead of Math.random(), use this function mathRand() for random number generation.
        // This function generates a random number between 0 and 1 with on-chain seed.

        let mathRand = sfc32(...cyrb128(seed));

    </script>
    <style>
        body {
            margin: 0px;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
            position: fixed;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
<script type="text/javascript">
    // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ Add traits here ↓↓↓↓↓↓↓↓↓↓↓↓↓↓

    function getTraits() {
        const trait1 = mathRand() < 0.5 ? 'Value 1' : 'Value 2';
        const trait2 = mathRand() < 0.3 ? true : false;

        const traits = {
            trait1,
            trait2,
        }
        
        return traits;
    }

    function reportTraits(traits) {
        window.$generativeTraits = {
            "Trait 1": traits.trait1,
            "Trait 2": traits.trait2,
        }
    }

    const traits = getTraits();
    reportTraits(traits);

    // ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ Add traits here ↑↑↑↑↑↑↑↑↑↑↑↑↑↑


    // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ Add your code here ↓↓↓↓↓↓↓↓↓↓↓↓↓↓
    /**
     * Inscription endpoint can be a uri of:
     * - JSON file describing a perceptron model
     * - Inscription of a Perceptron collection item (https://generative.xyz/generative/1002573)
     * - Token seed (from 1 to 580) of a Perceptron collection item (note that some item may not be minted and will lead to invalid model)
     */

    // const inscriptionEndpoint = `https://ordinals.com/content/d897386152f583d5f38b8f90b49882917b45765c1f665453b2f8d05f7e5d4397i0`;
    const inscriptionEndpoint = 12;

    const container = document.createElement("div");
    document.body.prepend(container);

    async function loadAndDisplayInfo() {
        // Load inscription
        container.innerHTML = "Loading...";
        const inscription = await getModelInscription(inscriptionEndpoint);

        if (inscription == null) {
            container.innerHTML = "Invalid inscription endpoint";
            return;
        }

        // Load model from inscription
        const model = new Model(inscription);
        container.innerHTML = "Loading completed.";

        // Display model information
        container.appendChild(createParagraph("Model information:"));

        const {inputDim, parameters, hiddenNeurons, activationFunc, modelName, classesName } = model.getInfo();

        const [h, w, c] = inputDim;
        const infoDesc = [
            `Model name: ${modelName}`,
            `Classes name: ${classesName.join(', ')}`,
            `Input dimension: ${h} x ${w} x ${c}`,
            `Hidden layer neurons count: ${hiddenNeurons.join(', ')}`,
            `Activation function: ${activationFunc}`,
        ];
        const infoList = createUnorderedList(infoDesc);
        container.appendChild(infoList);

        console.log(parameters);

        // Predict a randomly generated image and display result
        container.appendChild(createParagraph("Random image predicting result:"));

        imagePixels = [];
        for(let i = 0; i < w * h * c; ++i)
            imagePixels.push(Math.random() * 256);

        const result = model.classifyImage(imagePixels);
            
        const formatted_result = formatResult(result, classesName);
        const result_list = createUnorderedList(formatted_result);
        container.append(result_list);
    }

    function formatResult(result, classes_name) {
        const predictions = zip([result, classes_name]);

        const sorted_predictions = predictions.sort((a, b) => a[0] > b[0] ? -1 : 1);
        return sorted_predictions.map(e => `${e[1]}: ${(e[0] * 100).toFixed(2)}%`);
    }

    function createParagraph(text) {
        const div = document.createElement("div");
        div.innerText = text;
        return div;
    }

    function createUnorderedList(items) {        
        const ul = document.createElement("ul");
        items.forEach((text) => {
            const li = document.createElement("li");
            li.appendChild(document.createTextNode(text)); 
            ul.appendChild(li);
        })
        return ul
    }

    loadAndDisplayInfo();

    // ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ Add your code here ↑↑↑↑↑↑↑↑↑↑↑↑↑↑

</script>
</body>
</html>
